- 前言: 这是特定段的的加密，也就是无法控制在函数级别的加密，而且目前我只能实验成功在32位的so文件，64位的加密过程和32位大体一样，甚至我对着010看了一下午，结果发现该修改的地方都改了，效果在elf文件上还是体现出来了，但是始终闪退，有大佬知道也可以直接提issue给我，谢谢！

- 原理：  
1. 首先，先确定自己要加密的段是哪一个，同时将关键的函数都通过__attribute关键字（具体看代码）声明在要加密的那个段中
2. 然后开始对so文件下手，由于这里是通过段名的字符串比较，所以得先去找段字符串表节，把所有段名字符串找出来，这样就可以通过节头表中的name（是段名字符串表的下标），知道究竟哪个段是我们要加密的那个段
3. 接下来就是找段字符串表了，所以先通过elf文件头中，找到段名字符串表在节头表中的下标，节头表的偏移也知道，加上下标乘以节头表中每个节的信息结构体的大小，就找到了段名字符串表的信息结构体，再进而找到段名字符串表的实际偏移和大小
4. 然后申请一块内存空间，将这块数据取出来，进行加密
5. 之后再将加密后的数据放入原来的位置
6. 为了方便，直接将加密的偏移和大小以及所占页数放到文件头的有关section的信息中去，因为linker加载器是根据装载视角去加载的，也就意味着，它只会管程序头表的信息，section的信息它不是很关心，但是ida很关心，section信息缺少，ida解析会失败
# 总结:
其实比较好破，先弄清楚在哪里进行解密的，然后在那下断点，将so文件dump下来，再进行修复，修复等我看完动态链接之后再进行剖析